import { Transaction } from "../models/transaction.model.js";
import {
  validateUserAndBook,
  checkBookAvailability,
  calculateDays,
  getBookId,
  validateTransaction
} from "./helper.js";
import { ApiError } from "../utils/apiError.js";

//BookIssue
export const issueBookService = async (bookName, userId, issueDate) => {
  try {
    // Validate user and book
    const { userId: validatedUserId, bookId } = await validateUserAndBook(userId, bookName);
    
    // Check if the book is available
    await checkBookAvailability(bookId);

    // Create and save a new transaction
    const transaction = new Transaction({
      issuedBy: validatedUserId,
      issuedBook: bookId,
      issueDate: issueDate,
      status: "Issued",
    });

    return await transaction.save();
  } catch (error) {
    // console.error("Error issuing book:", error);
    throw new ApiError(error.statusCode ? error.statusCode : 500, error.message ? error.message : "Problem while issuing book");
  }
};

//BookReturn
export const returnBookService = async (bookName, userId, returnDate) => {
    try {
      // Validate user and book
      const { userId: validatedUserId, bookId, rent } = await validateUserAndBook(userId, bookName);
  
      // Check if there is a valid transaction for the book
      const transaction = await validateTransaction(validatedUserId, bookId);
  
      // Calculate the number of days and total rent
      const totalDays = await calculateDays(transaction.issueDate, returnDate);
      const totalRent = totalDays * rent;
  
      // Update and save the transaction
      transaction.returnDate = returnDate;
      transaction.rent = totalRent;
      transaction.status = "Returned";
  
      return await transaction.save();
    } catch (error) {
      // console.error("Error returning book:", error);
      throw new ApiError(error.statusCode ? error.statusCode : 500, error.message ? error.message : "Issue While Book Return");
    }
  };
 
// //Multiple Book realted services
  export const getBookPageInfoService = async (bookName) => {
    try {
      const bookId = await getBookId(bookName);
  
      // All users who have rented the book
      const allPastTransactions = await Transaction.find({
        issuedBook: bookId,
        status: "Returned",
      })
        .populate("issuedBy", "userName _id")
        .exec();
  
      // Users who currently have rented the book or its available status
      const currentStatus = await Transaction.find({
        issuedBook: bookId,
        status: "Issued",
      }).populate("issuedBy", "userName _id");
  
      const pastBorrowers = allPastTransactions.map((transaction) => ({
        userId: transaction.issuedBy._id,
        userName: transaction.issuedBy.userName,
        issueDate: transaction.issueDate,
        returnDate: transaction.returnDate,
      }));
  
      const RentalCount = pastBorrowers.length;
  
      const bookStatus = {};
  
      if (currentStatus.length > 0) {
        bookStatus.status = "Not available";
        bookStatus.RentedBy = currentStatus[0].issuedBy.userName; // As we there is always one issuer @ given/curr time
        bookStatus.issueDate = currentStatus[0].issueDate;
      } else {
        bookStatus.status = "Available";
      }
  
      return {
        pastBorrowers,
        RentalCount,
        bookStatus,
      };
    } catch (error) {
        throw new ApiError(error.statusCode ? error.statusCode : 500, error.message ? error.message : "Problem while issuing book");
    }
  };

//total rent generated by the book
  export const getTotalRentByBookService = async (bookName) => {
    try {
      const bookId = await getBookId(bookName);
  
      const transactions = await Transaction.find({
        issuedBook: bookId,
        status: "Returned",
        rent: { $ne: null },
      }).exec();
  
      return transactions.reduce(
        (sum, transaction) => sum + (transaction.rent || 0),
        0
      );
    } catch (error) {
      // Rethrow or handle the error as needed
      throw new Error(`Failed to get total rent by book: ${error.message}`);
    }
  };

//list of all books rented by particular user
  export const getUserIssuedBooksService = async (userId) => {
    try {
      const issuedBooks = await Transaction.find({ issuedBy: userId })
        .populate("issuedBook", "bookName")
        .exec();
  
      return issuedBooks.map((transaction) => ({
        bookId: transaction.issuedBook._id,
        bookName: transaction.issuedBook.bookName,
        issueDate: transaction.issueDate,
        returnDate: transaction.returnDate,
      }));
    } catch (error) {
      throw new Error(`Failed to get issued books for user: ${error.message}`);
    }
  };

//transaction in date range
  export const getTransactionsByDateRange = async (startDate, endDate) => {
    try {
      // Parse and validate dates
      const start = new Date(startDate);
      const end = new Date(endDate);
      if (isNaN(start.getTime()) || isNaN(end.getTime())) {
        throw new Error("Invalid date format. Please use YYYY-MM-DD format.");
      }
      end.setHours(23, 59, 59, 999);
  
      // Retrieve transactions within the date range
      const transactions = await Transaction.find({
        issueDate: { $gte: start, $lte: end },
      })
        .populate("issuedBook", "bookName")
        .populate("issuedBy", "userName")
        .exec();
  
      return transactions.map((transaction) => ({
        bookName: transaction.issuedBook.bookName,
        issuedTo: transaction.issuedBy.userName,
        issueDate: transaction.issueDate,
      }));
    } catch (error) {
      throw new Error(`Failed to get transactions by date range: ${error.message}`);
    }
  };